"""
This type stub file was generated by pyright.
"""

from xml.etree.ElementTree import TreeBuilder

from supervisor.compat import PY2, HTMLParser

AUTOCLOSE = ...
IGNOREEND = ...
_BLANK = ...
_SPACE = ...
_EQUAL = ...
_QUOTE = ...
_OPEN_TAG_START = ...
_CLOSE_TAG_START = ...
_OPEN_TAG_END = ...
_SELF_CLOSE = ...
_OMITTED_TEXT = ...
_COMMENT_START = ...
_COMMENT_END = ...
_PI_START = ...
_PI_END = ...
_AMPER_ESCAPED = ...
_LT = ...
_LT_ESCAPED = ...
_QUOTE_ESCAPED = ...
_XML_PROLOG_BEGIN = ...
_ENCODING = ...
_XML_PROLOG_END = ...
_DOCTYPE_BEGIN = ...
_PUBLIC = ...
_DOCTYPE_END = ...
if PY2:
    def encode(text, encoding):
        ...
    
else:
    def encode(text, encoding): # -> bytes:
        ...
    
def Replace(text, structure=...): # -> _MeldElementInterface:
    ...

class PyHelper:
    def findmeld(self, node, name, default=...):
        ...
    
    def clone(self, node, parent=...): # -> _MeldElementInterface:
        ...
    
    def bfclone(self, node, parent=...): # -> _MeldElementInterface:
        ...
    
    def getiterator(self, node, tag=...): # -> list[Unknown]:
        ...
    
    def content(self, node, text, structure=...): # -> None:
        ...
    


helper = ...
_MELD_NS_URL = ...
_MELD_PREFIX = ...
_MELD_LOCAL = ...
_MELD_ID = ...
_MELD_SHORT_ID = ...
_XHTML_NS_URL = ...
_XHTML_PREFIX = ...
_XHTML_PREFIX_LEN = ...
_marker = ...
class doctype:
    html_strict = ...
    html = ...
    xhtml_strict = ...
    xhtml = ...


class _MeldElementInterface:
    parent = ...
    attrib = ...
    text = ...
    tail = ...
    structure = ...
    def __init__(self, tag, attrib) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, index):
        ...
    
    def __getslice__(self, start, stop): # -> List[Unknown]:
        ...
    
    def getchildren(self): # -> list[Unknown]:
        ...
    
    def find(self, path):
        ...
    
    def findtext(self, path, default=...):
        ...
    
    def findall(self, path):
        ...
    
    def clear(self): # -> None:
        ...
    
    def get(self, key, default=...):
        ...
    
    def set(self, key, value): # -> None:
        ...
    
    def keys(self): # -> list[Unknown]:
        ...
    
    def items(self): # -> list[Unknown]:
        ...
    
    def getiterator(self, *ignored_args, **ignored_kw): # -> list[Unknown]:
        ...
    
    def __setitem__(self, index, element): # -> None:
        ...
    
    def __setslice__(self, start, stop, elements): # -> None:
        ...
    
    def append(self, element): # -> None:
        ...
    
    def insert(self, index, element): # -> None:
        ...
    
    def __delitem__(self, index): # -> None:
        ...
    
    def __delslice__(self, start, stop): # -> None:
        ...
    
    def remove(self, element): # -> None:
        ...
    
    def makeelement(self, tag, attrib): # -> _MeldElementInterface:
        ...
    
    def __mod__(self, other): # -> list[Unknown]:
        """ Fill in the text values of meld nodes in tree; only
        support dictionarylike operand (sequence operand doesn't seem
        to make sense here)"""
        ...
    
    def fillmelds(self, **kw): # -> list[Unknown]:
        """ Fill in the text values of meld nodes in tree using the
        keyword arguments passed in; use the keyword keys as meld ids
        and the keyword values as text that should fill in the node
        text on which that meld id is found.  Return a list of keys
        from **kw that were not able to be found anywhere in the tree.
        Never raises an exception. """
        ...
    
    def fillmeldhtmlform(self, **kw): # -> list[Unknown]:
        """ Perform magic to 'fill in' HTML form element values from a
        dictionary.  Unlike 'fillmelds', the type of element being
        'filled' is taken into consideration.

        Perform a 'findmeld' on each key in the dictionary and use the
        value that corresponds to the key to perform mutation of the
        tree, changing data in what is presumed to be one or more HTML
        form elements according to the following rules::

          If the found element is an 'input group' (its meld id ends
          with the string ':inputgroup'), set the 'checked' attribute
          on the appropriate subelement which has a 'value' attribute
          which matches the dictionary value.  Also remove the
          'checked' attribute from every other 'input' subelement of
          the input group.  If no input subelement's value matches the
          dictionary value, this key is treated as 'unfilled'.

          If the found element is an 'input type=text', 'input
          type=hidden', 'input type=submit', 'input type=password',
          'input type=reset' or 'input type=file' element, replace its
          'value' attribute with the value.

          If the found element is an 'input type=checkbox' or 'input
          type='radio' element, set its 'checked' attribute to true if
          the dict value is true, or remove its 'checked' attribute if
          the dict value is false.

          If the found element is a 'select' element and the value
          exists in the 'value=' attribute of one of its 'option'
          subelements, change that option's 'selected' attribute to
          true and mark all other option elements as unselected.  If
          the select element does not contain an option with a value
          that matches the dictionary value, do nothing and return
          this key as unfilled.

          If the found element is a 'textarea' or any other kind of
          element, replace its text with the value.

          If the element corresponding to the key is not found,
          do nothing and treat the key as 'unfilled'.

        Return a list of 'unfilled' keys, representing meld ids
        present in the dictionary but not present in the element tree
        or meld ids which could not be filled due to the lack of any
        matching subelements for 'select' nodes or 'inputgroup' nodes.
        """
        ...
    
    def findmeld(self, name, default=...):
        """ Find a node in the tree that has a 'meld id' corresponding
        to 'name'. Iterate over all subnodes recursively looking for a
        node which matches.  If we can't find the node, return None."""
        ...
    
    def findmelds(self): # -> list[Unknown]:
        """ Find all nodes that have a meld id attribute and return
        the found nodes in a list"""
        ...
    
    def findwithattrib(self, attrib, value=...): # -> list[Unknown]:
        """ Find all nodes that have an attribute named 'attrib'.  If
        'value' is not None, omit nodes on which the attribute value
        does not compare equally to 'value'. Return the found nodes in
        a list."""
        ...
    
    def repeat(self, iterable, childname=...): # -> list[Unknown]:
        """repeats an element with values from an iterable.  If
        'childname' is not None, repeat the element on which the
        repeat is called, otherwise find the child element with a
        'meld:id' matching 'childname' and repeat that.  The element
        is repeated within its parent element (nodes that are created
        as a result of a repeat share the same parent).  This method
        returns an iterable; the value of each iteration is a
        two-sequence in the form (newelement, data).  'newelement' is
        a clone of the template element (including clones of its
        children) which has already been seated in its parent element
        in the template. 'data' is a value from the passed in
        iterable.  Changing 'newelement' (typically based on values
        from 'data') mutates the element 'in place'."""
        ...
    
    def replace(self, text, structure=...): # -> None:
        """ Replace this element with a Replace node in our parent with
        the text 'text' and return the index of our position in
        our parent.  If we have no parent, do nothing, and return None.
        Pass the 'structure' flag to the replace node so it can do the right
        thing at render time. """
        ...
    
    def content(self, text, structure=...): # -> None:
        """ Delete this node's children and append a Replace node that
        contains text.  Always return None.  Pass the 'structure' flag
        to the replace node so it can do the right thing at render
        time."""
        ...
    
    def attributes(self, **kw): # -> None:
        """ Set attributes on this node. """
        ...
    
    def write_xmlstring(self, encoding=..., doctype=..., fragment=..., declaration=..., pipeline=...): # -> bytes:
        ...
    
    def write_xml(self, file, encoding=..., doctype=..., fragment=..., declaration=..., pipeline=...): # -> None:
        """ Write XML to 'file' (which can be a filename or filelike object)

        encoding    - encoding string (if None, 'utf-8' encoding is assumed)
                      Must be a recognizable Python encoding type.
        doctype     - 3-tuple indicating name, pubid, system of doctype.
                      The default is to prevent a doctype from being emitted.
        fragment    - True if a 'fragment' should be emitted for this node (no
                      declaration, no doctype).  This causes both the
                      'declaration' and 'doctype' parameters to become ignored
                      if provided.
        declaration - emit an xml declaration header (including an encoding
                      if it's not None).  The default is to emit the
                      doctype.
        pipeline    - preserve 'meld' namespace identifiers in output
                      for use in pipelining
        """
        ...
    
    def write_htmlstring(self, encoding=..., doctype=..., fragment=...): # -> bytes:
        ...
    
    def write_html(self, file, encoding=..., doctype=..., fragment=...): # -> None:
        """ Write HTML to 'file' (which can be a filename or filelike object)

        encoding    - encoding string (if None, 'utf-8' encoding is assumed).
                      Unlike XML output, this is not used in a declaration,
                      but it is used to do actual character encoding during
                      output.  Must be a recognizable Python encoding type.
        doctype     - 3-tuple indicating name, pubid, system of doctype.
                      The default is the value of doctype.html (HTML 4.0
                      'loose')
        fragment    - True if a "fragment" should be omitted (no doctype).
                      This overrides any provided "doctype" parameter if
                      provided.

        Namespace'd elements and attributes have their namespaces removed
        during output when writing HTML, so pipelining cannot be performed.

        HTML is not valid XML, so an XML declaration header is never emitted.
        """
        ...
    
    def write_xhtmlstring(self, encoding=..., doctype=..., fragment=..., declaration=..., pipeline=...): # -> bytes:
        ...
    
    def write_xhtml(self, file, encoding=..., doctype=..., fragment=..., declaration=..., pipeline=...): # -> None:
        """ Write XHTML to 'file' (which can be a filename or filelike object)

        encoding    - encoding string (if None, 'utf-8' encoding is assumed)
                      Must be a recognizable Python encoding type.
        doctype     - 3-tuple indicating name, pubid, system of doctype.
                      The default is the value of doctype.xhtml (XHTML
                      'loose').
        fragment    - True if a 'fragment' should be emitted for this node (no
                      declaration, no doctype).  This causes both the
                      'declaration' and 'doctype' parameters to be ignored.
        declaration - emit an xml declaration header (including an encoding
                      string if 'encoding' is not None)
        pipeline    - preserve 'meld' namespace identifiers in output
                      for use in pipelining
        """
        ...
    
    def clone(self, parent=...): # -> _MeldElementInterface:
        """ Create a clone of an element.  If parent is not None,
        append the element to the parent.  Recurse as necessary to create
        a deep clone of the element. """
        ...
    
    def deparent(self): # -> None:
        """ Remove ourselves from our parent node (de-parent) and return
        the index of the parent which was deleted. """
        ...
    
    def parentindex(self): # -> None:
        """ Return the parent node index in which we live """
        ...
    
    def shortrepr(self, encoding=...): # -> bytes:
        ...
    
    def diffmeld(self, other): # -> dict[str, dict[str, list[Unknown]]]:
        """ Compute the meld element differences from this node (the
        source) to 'other' (the target).  Return a dictionary of
        sequences in the form {'unreduced:
               {'added':[], 'removed':[], 'moved':[]},
                               'reduced':
               {'added':[], 'removed':[], 'moved':[]},}
                               """
        ...
    
    def meldid(self):
        ...
    
    def lineage(self): # -> list[Unknown]:
        ...
    


class MeldTreeBuilder(TreeBuilder):
    def __init__(self) -> None:
        ...
    
    def start(self, tag, attrs): # -> Element:
        ...
    
    def comment(self, data): # -> None:
        ...
    
    def doctype(self, name, pubid, system): # -> None:
        ...
    


class HTMLXMLParser(HTMLParser):
    """ A mostly-cut-and-paste of ElementTree's HTMLTreeBuilder that
    does special meld3 things (like preserve comments and munge meld
    ids).  Subclassing is not possible due to private attributes. :-("""
    def __init__(self, builder=..., encoding=...) -> None:
        ...
    
    def close(self): # -> Element:
        ...
    
    def handle_starttag(self, tag, attrs): # -> None:
        ...
    
    def handle_endtag(self, tag): # -> None:
        ...
    
    def handle_charref(self, char): # -> None:
        ...
    
    def handle_entityref(self, name): # -> None:
        ...
    
    def handle_data(self, data): # -> None:
        ...
    
    def unknown_entityref(self, name): # -> None:
        ...
    
    def handle_comment(self, data): # -> None:
        ...
    


def do_parse(source, parser): # -> Element:
    ...

def parse_xml(source): # -> Element:
    """ Parse source (a filelike object) into an element tree.  If
    html is true, use a parser that can resolve somewhat ambiguous
    HTML into XHTML.  Otherwise use a 'normal' parser only."""
    ...

def parse_html(source, encoding=...): # -> Element:
    ...

def parse_xmlstring(text): # -> Element:
    ...

def parse_htmlstring(text, encoding=...): # -> Element:
    ...

attrib_needs_escaping = ...
cdata_needs_escaping = ...
_HTMLTAGS_UNBALANCED = ...
_HTMLTAGS_NOESCAPE = ...
_HTMLATTRS_BOOLEAN = ...
_NONENTITY_RE = ...
_XML_DECL_RE = ...
_BEGIN_TAG_RE = ...
def insert_doctype(data, doctype=...):
    ...

def insert_meld_ns_decl(data):
    ...

def prefeed(data, doctype=...):
    ...

def sharedlineage(srcelement, tgtelement): # -> bool:
    ...

def diffreduce(elements): # -> list[Unknown]:
    ...

def intersection(S1, S2): # -> list[Unknown]:
    ...

def melditerator(element, meldid=..., _MELD_ID=...): # -> Generator[Unknown, None, None]:
    ...

_NON_ASCII_MIN = ...
_NON_ASCII_MAX = ...
_escape_map = ...
_namespace_map = ...
_pattern = ...
def fixtag(tag, namespaces): # -> tuple[str, tuple[str, str | Unknown] | None]:
    ...
