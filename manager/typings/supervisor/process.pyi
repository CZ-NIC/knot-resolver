"""
This type stub file was generated by pyright.
"""

import functools

@functools.total_ordering
class Subprocess:
    """A class to manage a subprocess."""
    pid = ...
    config = ...
    state = ...
    listener_state = ...
    event = ...
    laststart = ...
    laststop = ...
    laststopreport = ...
    delay = ...
    administrative_stop = ...
    system_stop = ...
    killing = ...
    backoff = ...
    dispatchers = ...
    pipes = ...
    exitstatus = ...
    spawnerr = ...
    group = ...
    def __init__(self, config) -> None:
        """Constructor.

        Argument is a ProcessConfig instance.
        """
        ...
    
    def removelogs(self): # -> None:
        ...
    
    def reopenlogs(self): # -> None:
        ...
    
    def drain(self): # -> None:
        ...
    
    def write(self, chars): # -> None:
        ...
    
    def get_execv_args(self): # -> tuple[str | None, List[str]]:
        """Internal: turn a program name into a file name, using $PATH,
        make sure it exists / is executable, raising a ProcessException
        if not """
        ...
    
    event_map = ...
    def change_state(self, new_state, expected=...): # -> Literal[False] | None:
        ...
    
    def record_spawnerr(self, msg): # -> None:
        ...
    
    def spawn(self): # -> None:
        """Start the subprocess.  It must not be running already.

        Return the process id.  If the fork() call fails, return None.
        """
        ...
    
    def stop(self): # -> str | None:
        """ Administrative stop """
        ...
    
    def stop_report(self): # -> None:
        """ Log a 'waiting for x to stop' message with throttling. """
        ...
    
    def give_up(self): # -> None:
        ...
    
    def kill(self, sig): # -> str | None:
        """Send a signal to the subprocess with the intention to kill
        it (to make it exit).  This may or may not actually kill it.

        Return None if the signal was sent, or an error message string
        if an error occurred or if the subprocess is not running.
        """
        ...
    
    def signal(self, sig): # -> str | None:
        """Send a signal to the subprocess, without intending to kill it.

        Return None if the signal was sent, or an error message string
        if an error occurred or if the subprocess is not running.
        """
        ...
    
    def finish(self, pid, sts): # -> None:
        """ The process was reaped and we need to report and manage its state
        """
        ...
    
    def set_uid(self): # -> None:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def get_state(self): # -> int | None:
        ...
    
    def transition(self): # -> None:
        ...
    


class FastCGISubprocess(Subprocess):
    """Extends Subprocess class to handle FastCGI subprocesses"""
    def __init__(self, config) -> None:
        ...
    
    def before_spawn(self): # -> None:
        """
        The FastCGI socket needs to be created by the parent before we fork
        """
        ...
    
    def spawn(self): # -> None:
        """
        Overrides Subprocess.spawn() so we can hook in before it happens
        """
        ...
    
    def after_finish(self): # -> None:
        """
        Releases reference to FastCGI socket when process is reaped
        """
        ...
    
    def finish(self, pid, sts): # -> None:
        """
        Overrides Subprocess.finish() so we can hook in after it happens
        """
        ...
    


@functools.total_ordering
class ProcessGroupBase:
    def __init__(self, config) -> None:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def removelogs(self): # -> None:
        ...
    
    def reopenlogs(self): # -> None:
        ...
    
    def stop_all(self): # -> None:
        ...
    
    def get_unstopped_processes(self): # -> list[Unknown]:
        """ Processes which aren't in a state that is considered 'stopped' """
        ...
    
    def get_dispatchers(self): # -> dict[Unknown, Unknown]:
        ...
    
    def before_remove(self): # -> None:
        ...
    


class ProcessGroup(ProcessGroupBase):
    def transition(self): # -> None:
        ...
    


class FastCGIProcessGroup(ProcessGroup):
    def __init__(self, config, **kwargs) -> None:
        ...
    


class EventListenerPool(ProcessGroupBase):
    def __init__(self, config) -> None:
        ...
    
    def handle_rejected(self, event): # -> None:
        ...
    
    def transition(self): # -> None:
        ...
    
    def before_remove(self): # -> None:
        ...
    
    def dispatch(self): # -> None:
        ...
    


class GlobalSerial:
    def __init__(self) -> None:
        ...
    


GlobalSerial = ...
def new_serial(inst):
    ...
