"""
This type stub file was generated by pyright.
"""

from supervisor.medusa import asyncore_25 as asyncore

r"""A class supporting chat-style (command/response) protocols.

This class adds support for 'chat' style protocols - where one side
sends a 'command', and the other sends a response (examples would be
the common internet protocols - smtp, nntp, ftp, etc..).

The handle_read() method looks at the input stream for the current
'terminator' (usually '\r\n' for single-line responses, '\r\n.\r\n'
for multi-line output), calling self.found_terminator() on its
receipt.

for example:
Say you build an async nntp client using this class.  At the start
of the connection, you'll have self.terminator set to '\r\n', in
order to process the single-line greeting.  Just before issuing a
'LIST' command you'll set it to '\r\n.\r\n'.  The output of the LIST
command will be accumulated (using your own 'collect_incoming_data'
method) up to the terminator, and then control will be returned to
you - by calling your self.found_terminator() method.
"""
class async_chat(asyncore.dispatcher):
    """This is an abstract class.  You must derive from this class, and add
    the two methods collect_incoming_data() and found_terminator()"""
    ac_in_buffer_size = ...
    ac_out_buffer_size = ...
    def __init__(self, conn=..., map=...) -> None:
        ...
    
    def collect_incoming_data(self, data):
        ...
    
    def found_terminator(self):
        ...
    
    def set_terminator(self, term): # -> None:
        """Set the input delimiter.  Can be a fixed string of any length, an integer, or None"""
        ...
    
    def get_terminator(self): # -> int:
        ...
    
    def handle_read(self): # -> None:
        ...
    
    def handle_write(self): # -> None:
        ...
    
    def handle_close(self): # -> None:
        ...
    
    def push(self, data): # -> None:
        ...
    
    def push_with_producer(self, producer): # -> None:
        ...
    
    def readable(self): # -> bool:
        """predicate for inclusion in the readable for select()"""
        ...
    
    def writable(self): # -> bool:
        """predicate for inclusion in the writable for select()"""
        ...
    
    def close_when_done(self): # -> None:
        """automatically close this channel once the outgoing queue is empty"""
        ...
    
    def refill_buffer(self): # -> None:
        ...
    
    def initiate_send(self): # -> None:
        ...
    
    def discard_buffers(self): # -> None:
        ...
    


class simple_producer:
    def __init__(self, data, buffer_size=...) -> None:
        ...
    
    def more(self): # -> bytes:
        ...
    


class fifo:
    def __init__(self, list=...) -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def is_empty(self): # -> bool:
        ...
    
    def first(self):
        ...
    
    def push(self, data): # -> None:
        ...
    
    def pop(self): # -> tuple[Literal[1], Unknown] | tuple[Literal[0], None]:
        ...
    


def find_prefix_at_end(haystack, needle): # -> int:
    ...
