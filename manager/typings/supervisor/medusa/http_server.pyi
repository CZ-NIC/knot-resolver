"""
This type stub file was generated by pyright.
"""

import supervisor.medusa.asynchat_25 as asynchat
import supervisor.medusa.asyncore_25 as asyncore

RCS_ID = ...
VERSION_STRING = ...
class http_request:
    reply_code = ...
    request_counter = ...
    use_chunked = ...
    collector = ...
    def __init__(self, *args) -> None:
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __getitem__(self, key): # -> str:
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def has_key(self, key): # -> bool:
        ...
    
    def build_reply_header(self): # -> bytes:
        ...
    
    def add_header(self, name, value): # -> None:
        """ Adds a header to the reply headers """
        ...
    
    def clear_headers(self): # -> None:
        """ Clears the reply header list """
        ...
    
    def remove_header(self, name, value=...): # -> None:
        """ Removes the specified header.
        If a value is provided, the name and
        value must match to remove the header.
        If the value is None, removes all headers
        with that name."""
        ...
    
    def get_reply_headers(self): # -> List[Unknown]:
        """ Get the tuple of headers that will be used
        for generating reply headers"""
        ...
    
    def get_reply_header_text(self): # -> str:
        """ Gets the reply header (including status and
        additional crlf)"""
        ...
    
    path_regex = ...
    def split_uri(self): # -> Tuple[str | Any, ...]:
        ...
    
    def get_header_with_regex(self, head_reg, group): # -> Literal['']:
        ...
    
    def get_header(self, header): # -> None:
        ...
    
    def collect_incoming_data(self, data): # -> None:
        ...
    
    def found_terminator(self): # -> None:
        ...
    
    def push(self, thing): # -> None:
        ...
    
    def response(self, code=...): # -> str:
        ...
    
    def error(self, code): # -> None:
        ...
    
    reply_now = ...
    def done(self): # -> None:
        """finalize this transaction - send output to the http channel"""
        ...
    
    def log_date_string(self, when): # -> str:
        ...
    
    def log(self, bytes): # -> None:
        ...
    
    responses = ...
    DEFAULT_ERROR_MESSAGE = ...
    def log_info(self, msg, level): # -> None:
        ...
    


class http_channel(asynchat.async_chat):
    ac_out_buffer_size = ...
    current_request = ...
    channel_counter = ...
    def __init__(self, server, conn, addr) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    maintenance_interval = ...
    def check_maintenance(self): # -> None:
        ...
    
    def maintenance(self): # -> None:
        ...
    
    zombie_timeout = ...
    def kill_zombies(self): # -> None:
        ...
    
    def send(self, data): # -> int:
        ...
    
    def recv(self, buffer_size): # -> bytes:
        ...
    
    def handle_error(self): # -> None:
        ...
    
    def log(self, *args): # -> None:
        ...
    
    def collect_incoming_data(self, data): # -> None:
        ...
    
    def found_terminator(self): # -> None:
        ...
    
    def writable_for_proxy(self): # -> bool | Literal[1] | None:
        ...
    


class http_server(asyncore.dispatcher):
    SERVER_IDENT = ...
    channel_class = http_channel
    def __init__(self, ip, port, resolver=..., logger_object=...) -> None:
        ...
    
    def writable(self): # -> Literal[0]:
        ...
    
    def handle_read(self): # -> None:
        ...
    
    def readable(self): # -> bool:
        ...
    
    def handle_connect(self): # -> None:
        ...
    
    def handle_accept(self): # -> None:
        ...
    
    def install_handler(self, handler, back=...): # -> None:
        ...
    
    def remove_handler(self, handler): # -> None:
        ...
    
    def status(self): # -> composite_producer:
        ...
    


def maybe_status(thing): # -> None:
    ...

CONNECTION = ...
def join_headers(headers): # -> list[Unknown]:
    ...

def get_header(head_reg, lines, group=...): # -> Literal['']:
    ...

def get_header_match(head_reg, lines): # -> Literal['']:
    ...

REQUEST = ...
def crack_request(r): # -> tuple[str | Any, str | Any, str | Any | None] | tuple[None, None, None]:
    ...

if __name__ == '__main__':
    ...
