"""
This type stub file was generated by pyright.
"""

"""
Logger implementation loosely modeled on PEP 282.  We don't use the
PEP 282 logger implementation in the stdlib ('logging') because it's
idiosyncratic and a bit slow for our purposes (we don't use threads).
"""
class LevelsByName:
    CRIT = ...
    ERRO = ...
    WARN = ...
    INFO = ...
    DEBG = ...
    TRAC = ...
    BLAT = ...


class LevelsByDescription:
    critical = ...
    error = ...
    warn = ...
    info = ...
    debug = ...
    trace = ...
    blather = ...


LOG_LEVELS_BY_NUM = ...
def getLevelNumByDescription(description): # -> Any | None:
    ...

class Handler:
    fmt = ...
    level = ...
    def __init__(self, stream=...) -> None:
        ...
    
    def setFormat(self, fmt): # -> None:
        ...
    
    def setLevel(self, level): # -> None:
        ...
    
    def flush(self): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def emit(self, record): # -> None:
        ...
    
    def handleError(self): # -> None:
        ...
    


class StreamHandler(Handler):
    def __init__(self, strm=...) -> None:
        ...
    
    def remove(self): # -> None:
        ...
    
    def reopen(self): # -> None:
        ...
    


class BoundIO:
    def __init__(self, maxbytes, buf=...) -> None:
        ...
    
    def flush(self): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def write(self, b): # -> None:
        ...
    
    def getvalue(self): # -> Unknown | bytes:
        ...
    
    def clear(self): # -> None:
        ...
    


class FileHandler(Handler):
    """File handler which supports reopening of logs.
    """
    def __init__(self, filename, mode=...) -> None:
        ...
    
    def reopen(self): # -> None:
        ...
    
    def remove(self): # -> None:
        ...
    


class RotatingFileHandler(FileHandler):
    def __init__(self, filename, mode=..., maxBytes=..., backupCount=...) -> None:
        """
        Open the specified file and use it as the stream for logging.

        By default, the file grows indefinitely. You can specify particular
        values of maxBytes and backupCount to allow the file to rollover at
        a predetermined size.

        Rollover occurs whenever the current log file is nearly maxBytes in
        length. If backupCount is >= 1, the system will successively create
        new files with the same pathname as the base file, but with extensions
        ".1", ".2" etc. appended to it. For example, with a backupCount of 5
        and a base file name of "app.log", you would get "app.log",
        "app.log.1", "app.log.2", ... through to "app.log.5". The file being
        written to is always "app.log" - when it gets filled up, it is closed
        and renamed to "app.log.1", and if files "app.log.1", "app.log.2" etc.
        exist, then they are renamed to "app.log.2", "app.log.3" etc.
        respectively.

        If maxBytes is zero, rollover never occurs.
        """
        ...
    
    def emit(self, record): # -> None:
        """
        Emit a record.

        Output the record to the file, catering for rollover as described
        in doRollover().
        """
        ...
    
    def removeAndRename(self, sfn, dfn): # -> None:
        ...
    
    def doRollover(self): # -> None:
        """
        Do a rollover, as described in __init__().
        """
        ...
    


class LogRecord:
    def __init__(self, level, msg, **kw) -> None:
        ...
    
    def asdict(self): # -> dict[str, str | Unknown]:
        ...
    


class Logger:
    def __init__(self, level=..., handlers=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def blather(self, msg, **kw): # -> None:
        ...
    
    def trace(self, msg, **kw): # -> None:
        ...
    
    def debug(self, msg, **kw): # -> None:
        ...
    
    def info(self, msg, **kw): # -> None:
        ...
    
    def warn(self, msg, **kw): # -> None:
        ...
    
    def error(self, msg, **kw): # -> None:
        ...
    
    def critical(self, msg, **kw): # -> None:
        ...
    
    def log(self, level, msg, **kw): # -> None:
        ...
    
    def addHandler(self, hdlr): # -> None:
        ...
    
    def getvalue(self):
        ...
    


class SyslogHandler(Handler):
    def __init__(self) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def reopen(self): # -> None:
        ...
    
    def emit(self, record): # -> None:
        ...
    


def getLogger(level=...): # -> Logger:
    ...

_2MB = ...
def handle_boundIO(logger, fmt, maxbytes=...): # -> None:
    """Attach a new BoundIO handler to an existing Logger"""
    ...

def handle_stdout(logger, fmt): # -> None:
    """Attach a new StreamHandler with stdout handler to an existing Logger"""
    ...

def handle_syslog(logger, fmt): # -> None:
    """Attach a new Syslog handler to an existing Logger"""
    ...

def handle_file(logger, filename, fmt, rotating=..., maxbytes=..., backups=...): # -> None:
    """Attach a new file handler to an existing Logger. If the filename
    is the magic name of 'syslog' then make it a syslog handler instead."""
    ...
